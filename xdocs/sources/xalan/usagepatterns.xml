<?xml version="1.0" standalone="no"?> 
<!DOCTYPE s1 SYSTEM "../../style/dtd/document.dtd">
<!--
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Xalan" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, Lotus
 * Development Corporation., http://www.lotus.com.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 -->
<s1 title="&xslt4c; Basic usage patterns">
<ul>
<li><link anchor="intro">Introduction</link></li>
<li><link anchor="xalantransformer">Using the XalanTransformer class</link></li>
<li><link anchor="basic">Basic procedure for performing XSL transformations</link></li>
<li><link anchor="dom">Working with DOM input and output</link></li>
<li><link anchor="params">Setting stylesheet parameters</link></li>
<li><link anchor="compiled">Compiling stylesheets</link></li>
<li><link anchor="xpath">Working with XPath expressions</link></li>
<li><link anchor="tracelistener">Using the TraceListener</link></li>
<li><link anchor="icu">Using the International Components for Unicode (ICU)</link></li>
<li>See also: <link idref="extensions">Creating and using extension functions</link></li>
</ul><anchor name="intro"/>

  <s2 title="Introduction">  
<p>&xslt4c; takes as primary input an XML source document and an XSL stylesheet, both represented by instances of <jump href="apidocs/class_XSLTInputSource.html">XSLTInputSource</jump>. These input objects may each take the form of a file or URL, a stream, or a DOM tree. The stylesheet may also take the form of a compiled stylesheet (an instance of <jump href="apidocs/class_stylesheetroot.html">StylesheetRoot</jump>).</p>
<note>If the XML source document contains a stylesheet Processing Instruction (PI), &xslt4c; uses the stylesheet this PI points to and a separate stylesheet object is not required. </note>
<p>&xslt4c; uses &xml4c; to parse text input, performs the transformation, and sends the output to an instance of <jump href="apidocs/class_xsltresulttarget.html">XSLTResultTarget</jump>, which may be configured to write to a file, a stream, or a DOM tree.</p>
<p>For detailed API documentation, see <jump href="apidocs/index.html">&xslt4c; API</jump>. For an overview of the
command-line utility, see <link idref="commandline">Command-Line Utility</link>.</p>
</s2><anchor name="xalantransformer"/>
<s2 title="Using the XalanTransformer class">
<p>&xslt4c; 1.2 introduces XalanTransformer, a new class designed to package the basic Xalan infrastructure and provide a simpler C++ 
and C API for performing standard transformations.</p>
<note>As we expand the functionality of the XalanTransformer, we will revise the remainder of this chapter and the samples to indicate 
how to take advantage of the API it provides.</note>
<ul>
  <li><link anchor="cpp">Basic usage pattern with the XalanTransformer C++ API</link></li>
  <li><link anchor="cppvar">Variations with the XalanTransformer C++ API</link></li>  
  <li><link anchor="capi">Basic usage pattern with the XalanTransformer C API</link></li>
  <li><link anchor="cvar">Variations with the XalanTransformer C API</link></li>  
</ul><anchor name="cpp"/>
<s3 title="Basic usage patten with XalanTransformer C++ API">
<p>Using XalanTransformer and the C++ API, you can perform one or more transformations as follows:</p>
<ol>
  <li>Include the XalanTransformer header file.<br/>
  <code>#include &lt;XalanTransformer/XalanTransformer.hpp</code><br/><br/></li>
  <li>Initialize Xalan and Xerces.<br/>
  <code>XalanTransformer::initialize();</code><br/><br/></li>
  <li>Create a XalanTransformer.<br/>
  <code>XalanTransformer theXalanTransformer;</code><br/><br/></li>
  <li>Use one of the XalanTransformer transform() methods to perform each transformation. For example:<br/>
  <code>const char* xmlIn = "foo.xml";</code><br/>
  <code>const char* xslSheet = "foo.xsl";</code><br/>
  <code>const char* xmlOut = "foo.out";</code><br/>
  <code>int theResult = 0;</code><br/>
  <code>theResult = theXalanTransformer(xmlIn,xslSheet,xmlOut);</code><br/><br/></li>
  <li>Shut down Xalan and Xerces.<br/>
  <code>XalanTransformer::terminate();</code></li>
</ol>
</s3><anchor name="cppvar"/>
<s3 title="Variations with the XalanTransformer C++ API">
<p>The XalanTransformer transform() methods also allow you to process and produce streams, and to send the output in blocks to a callback 
function, which means you can begin processing the output while the transformation is still in progress. Each transform() method returns 
an integer code, 0 for success. If an error occurs, you can use the getLastError() method to return a pointer to the error message. 
For the details, see XalanTransormer/XalanTransformer.hpp in the source tree. For an example, see the 
<link idref="samples" anchor="xalantransform">XalanTransform</link> sample.</p>
<p>Transform an XML file to an output file. The XML file contains a stylesheeet processing instruction.</p>
<source>int
transform(
const  char*  xmlInFile, 
const  char*  xmlOutFile);</source>
<p>Transform from files to an output stream:</p>
<source>int
transform(const char* xmlInFile,
          const char* xslFile,
          ostream&amp;    resultOutStream);</source>
<p>Transform from input streams to an output stream:</p>
<source>int
transform(istream&amp; xmlInStream,
          istream&amp; xslInStram,
          ostream&amp; resultOutStream);</source>
<p>Transform from files to an output handler that receives the output in blocks. </p>          
<source>int
transform(const char* xmlInFile
          const char* xslFile,
          XalanOutputHandlerType theOutputHandler
          XalanFlushHanderType theFlushHandler = 0);</source>
<p>The transform() method that the other transform() methods all call:</p>
<source>int
transform( const XSLTInputSource&amp; xmlInput,
           const XSLTInputSource&amp; xslStylesheet,
           const XSLTResultTarget&amp; transformResult);</source>
                                            
</s3><anchor name="capi"/>
<s3 title="Basic XalanTransformer usage pattern with the C API">
<p>We also include a simple C interface for using the XalanTransformer class. See XalanTransformer/XalanCAPI.h in the source tree. 
The <link idref="samples" anchor="apachemodulexslt">ApacheModuleXSLT</link> sample illustrates the use of this C API.</p>
<p>Basic strategy:</p>
<ol>
  <li>Include the XalanTransformer C API header.<br/>
  <code>#include &lt;XalanTransformer/XalanCAPI.h&gt;</code><br/><br/></li>
  <li>Initialize Xalan and Xerces<br/>
  <code>XalanInitialize();</code><br/><br/></li>  
  <li>Create a Xalan transformer<br/>
  <code>XalanHandle xalan = NULL;</code><br/>
  <code>xalan = CreateXalanTransformer();</code><br/><br/></li>
  <li>Perform each transformation. For example:<br/>
  <code>char * xmlfilename = "foo.xml";</code><br/>
  <code>char xslfilename = "foo.xsl";</code><br/>
  <code>char outfilename = "foo.out";</code><br/>  
  <code>int theResult = 0;</code><br/>
  <code>theResult = XalanTransformToFile(xmlfilename,</code><br/>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xslfilename,</code><br/>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outfilename,</code><br/>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xalan);</code><br/><br/></li>
  <li>Shut down Xalan and Xerces<br/>
  <code>XalanTerminate();</code></li>
</ol>
</s3><anchor name="cvar"/>
<s3 title="Variations with the XalanTransformer C API">
<p>The C API supports basically the same options as the C++ API.</p>
<p>Transform from files to a character array:</p>
<source>int
XalanTransformToData(const char*  xmlInFile,
                     const char*  xslFile,
                     const char** transformOutput,
                     XalanHandle  xalan);</source>
<p>After calling XalanTransformToData(), call XalanFreeData() with the address of the pointer to the character array:</p>
<p><code>XalanFreeData(transformOutput);</code></p>
<p>Transform to a callback function that receives the output in blocks (see the <link idref="samples" 
anchor="apachemodulexslt">ApacheModuleXSLT</link> sample).</p>
<source>int
XalanTransformToHandler(const char*  xmlInFile,
                        const char*  xslFile,
                        XalanHandle xalan,
                        const void* outputHandle,
                        XalanOutputHandlerType outputHandler,
                        XalanFlushHandlerType flushHandler);</source>
</s3>
</s2><anchor name="basic"/>
<s2 title="Basic procedure for performing an XSL transformation">
<p>When you are setting up your application to use XSL stylesheets to transform XML documents, you must do the following:</p>
<s3 title="1. Include the required header files">
<p>Always start with Include/PlatformDefinitions.hpp, the &xslt4c; base header file. Along with any additional &xslt4c; and other header files that are required for the particular application, be sure to include utils/PlatformUtils.hpp from the &xml4c; distribution.</p>
</s3>
<s3 title="2. Initialize Xalan and Xerces">
<p>Use the static initializers to initialize the &xslt4c; and &xml4c; platforms. You only need to do this once per session.</p>
<source>XMLPlatformUtils::Initialize();
XSLTInit  theInit;</source>
</s3><anchor name="step3"/>
<s3 title="3. Set up an XSLT processor with its support objects">
<p>The XSLT processor interacts with several support objects that you must set up before you can perform transformations.</p>
<source>// Create the support objects.
XercesDOMSupport           theDOMSupport;
XercesParserLiaison        theParserLiaison(theDOMSupport);
XPathSupportDefault        theXPathSupport(theDOMSupport);
XSLTProcessorEnvSupportDefault  theXSLTProcessorEnvSupport;
XObjectFactoryDefault      theXObjectFactory;
XPathFactoryDefault        theXPathFactory;

// Create the processor.
XSLTEngineImpl  theProcessor(
          theParserLiaison,
          theXPathSupport,
          theXSLTProcessorEnvSupport,
          theDOMSupport,
          theXObjectFactory,
          theXPathFactory);

// Connect the processor to the environment support object.
theXSLTProcessorEnvSupport.setProcessor(&amp;theProcessor);</source>
</s3>
<s3 title="4. Create context objects for the stylesheet">
<p>Use the processor and support objects to set up stylesheet construction context and execution context objects.</p>
<source>
StylesheetConstructionContextDefault  theConstructionContext(
            theProcessor,
            theXSLTProcessorEnvSupport,
            theXPathFactory);
StylesheetExecutionContextDefault      theExecutionContext(
            theProcessor,
            theXSLTProcessorEnvSupport,
            theXPathSupport,
            theXObjectFactory);</source>
</s3>
<s3 title="5. Set up input and output objects for a transformation">
<p>You must set up XSLTInputSource objects for the XML document and XSL stylesheet, and an XSLTResultTarget object to contain the transformation output.</p>
<p>Each of these objects may take the form of a file or URL, a stream, or a DOM tree. In the following fragment, the input and output are files:</p>
<source>// Use XalanDOMString to create a Unicode file name.
// The files are in the same directory as the application executable.
const XalanDOMString    theXMLFileName("foo.xml");
const XalanDOMString    theXSLFileName("foo.xsl");

// Create XSLTInputSource objects.
XSLTInputSource    theInputSource(c_wstr(theXMLFileName));
XSLTInputSource    theStylesheetSource(c_wstr(theXSLFileName));

// For the output, create an XSLTResultTarget object.
const XalanDOMString    theOutputFile("foo.out");
XSLTResultTarget		theResultTarget(theOutputFile);
</source>
<p>For the other constructors you can use to set up input and output objects (with input and output streams, for example), see <jump href="apidocs/class_xsltinputsource.html">XSLTInputSource</jump> and <jump href="apidocs/class_xsltresulttarget.html">XSLTResultTarget</jump>. See also <link anchor="dom">Working with
DOM input and output</link>.</p>
</s3><anchor name="process"/>
<s3 title="6. Perform the transformation">
<p>Use the XSLTEngineImpl process() method to perform the transformation.</p>
<source>
theProcessor.process(
               theInputSource,
               theStylesheetSource,
               theResultTarget,
               theConstructionContext,
               theExecutionContext);</source>
<p>The XSLTResultTarget object receives the transformation output.</p>
<p>XSLTEngineImpl stores running state information, so it is not thread-safe. To perform multiple transformations, create a new instance for each transformation, or call the XSLTProcessor reset() method between each transformation.</p> 
<p>If you are using the same stylesheet to perform multiple transformations, for efficiency you should compile the stylesheet and use the appropriate XSLTEngineImpl process() method. Compiled stylesheet (StylesheetRoot) objects are also thread-safe. A single StylesheetRoot object may be called concurrently from multiple threads. For more information, see <link anchor="compiled">Compiling stylesheets</link>.</p>
</s3>
<s3 title="7. Shut down Xerces.">
<p>When you are done performing transformations, shut down Xerces.</p>
<source>// Call the static terminator for Xerces.
XMLPlatformUtils::Terminate();
</source>
<p>For a sample application that performs a transformation, see <link idref="samples" anchor="simpletransform">SimpleTransform</link>.</p> 
</s3>
</s2><anchor name="dom"/>
<s2 title="Working with DOM input and output">
<p>You can set up an XSLTResultTarget to produce a DOM when you perform a transformation. You can also use a DOM as input for a transformation, either the DOM output of another transformation, or a DOM produced by the Xerces DOMParser.</p>
<p>The following code fragments illustrate the procedures for working with DOM input and output:</p>
<source>

// Use the Xerces DOM parser to create a DOM_Document.
#include &lt;parsers/DOMParser.hpp&gt;
#include &lt;dom/DOM_Node.hpp&gt;

DOMParser  theParser;
theParser.parse("foo.xml");
const DOM_Document theDOM = theParser.getDocument();

// Set up a XercesParserLiaison and use it to wrap the DOM_Document
// in a XalanDocument.
DOMSupportDefault   theDOMSupport;
XercesParserLiaison	theParserLiaison(theDOMSupport);
XalanDocument* theDoc = theParserLiaison.createDocument(theDOM);

// Use the XalanDocument to create an XSLTInputSource object, which
// you can then use in a transformation.
XSLTInputSource		theInputSource(theDoc);
...
// If you want to produce DOM output, create an empty XalanDocument
// to contain the transformation output.
XalanDocument* docOut = theParserLiaison.createDocument();
XSLTResultTarget theDOMResultTarget(docOut);
...
// After you perform the transformation, the XalanDocument contains
// the output.
// You can also convert the XalanDocument to a Xerces DOM_Document.
DOM_Document domOut = theParserLiaison.mapXercesDocument(docOut)</source>
</s2><anchor name="params"/>
<s2 title="Setting stylesheet parameters">
<p>An XSL stylesheet can include parameters that are set at run time before a transformation takes place. When we generate the HTML documents that make up the Xalan doc set, for example, we send the stylesheet an id parameter along with each XML source document. The id identifies that document and enables the stylesheet to integrate it into the overall doc set.</p>
<p>To set a stylesheet parameter, use one of the <jump href="apidocs/class_xsltengineimpl.html">XSLTEngineImpl</jump> setStylesheetParam() methods. Both methods take two arguments: the parameter name (a XalanDOMstring) and the expression (a XalanDOMString or an XObject). The XObject option is useful when you are working with the XPath API. For example, you could use the XObject returned by an Xpath function to set a stylesheet parameter.</p>
<note>If the expression is a string and you are using XalanDOMString for the input parameter, enclose it in single quotes to make it a string expression.</note>
<p>You can include the -param flag with two arguments when you call the <link idref="commandline">command line utility</link>. The first argument is the parameter name or key, and the second argument is the string expression (in single quotes). For example:</p>
<p><code>TestXSLT -in foo.xml -xsl foo.xsl -param param1 'boo'</code></p>
<p>If the string expression includes spaces or other characters that the shell intercepts, first enclose the string in single quotes so &xslt4c; interprets it as a string expression, and then enclose the resulting string in double quotes so the shell interprets it as a single argument. For example:</p>
<p><code>TestXSLT -in foo.xml -xsl foo.xsl -param param1 "'hello there'"</code></p>
<p>The <link idref="samples" anchor="usestylesheetparam">UseStylesheetParam</link> sample application also uses a command-line parameter.</p>
</s2><anchor name="compiled"/>
<s2 title="Compiling stylesheets">
<p>When &xslt4c; performs a transformation with the <link anchor="process">XSLTEngineImpl process() method used above</link>, it starts by compiling the stylesheet into a binary representation. If you intend to use the same stylesheet to perform multiple transformations, you can enhance efficiency by explicitly compiling the stylesheet and using another XSLTEngimeImpl process() method for each transformation. A compiled stylesheet (a <jump href="apidocs/class_stylesheetroot.html">StylesheetRoot</jump> object) is thread safe, so it even supports concurrent access by multiple clients. If, for example, you are setting up a server application to perform transformations, you can improve performance by compiling any stylesheets the application repeatedly uses.</p>
<p>A compiled stylesheet requires its own XPath factory support object, independent of the XPath support object for an XSLT processor. So after you have set up the XSLT processor with its support objects, set up another XPath
factory support object and use it to create a construction context for the stylesheet:</p>
<source>// Set up the XSLT processor with its support objects
XercesDOMSupport           theDOMSupport;
XercesParserLiaison        theParserLiaison(theDOMSupport);
XPathSupportDefault        theXPathSupport(theDOMSupport);
XSLTProcessorEnvSupportDefault  theXSLTProcessorEnvSupport;
XObjectFactoryDefault      theXObjectFactory;
XPathFactoryDefault        theXPathFactory;

// Create the processor and connect to the
// environment support object.
XSLTEngineImpl  theProcessor(
          theParserLiaison,
          theXPathSupport,
          theXSLTProcessorEnvSupport,
          theDOMSupport;
          theXObjectFactory,
          theXPathFactory);
theXSLTProcessorEnvSupport.setProcessor(&amp;theProcessor);
...
// Create an XPath factory support object for the stylesheet,
// so it will have its own factory-created XPath instances
// (separate from the XSLT processor XPath objects).
XPathFactoryDefault        theStylesheetXPathFactory;

// Use this XPath factory support object to create a stylesheet 
// construction context.
StylesheetConstructionContextDefault  theConstructionContext(
            theProcessor,
            theXSLTProcessorEnvSupport,
            theStylesheetXPathFactory);

 // The execution context uses the same factory support objects as
 // the processor.
 StylesheetExecutionContextDefault    theExecutionContext(
            theProcessor,
            theXSLTProcessorEnvSupport,
            theXPathSupport,
            theXObjectFactory);</source>
<p>Compile the stylesheet, add the StylesheetRoot object to the execution context, and start performing transformations. Use the XSLTEngineImpl process() method (see below) that takes advantage of the compiled stylesheet. Be sure to reset the processor and execution context between each transformation. For example:</p>
<source>
// Compile the stylesheet.
StylesheetRoot* const	theStylesheetRoot =
          theProcessor.processStylesheet(
                theStylesheetSource,
                theConstructionContext);
          assert(theStylesheetRoot != 0);

// Set the execution context object to use the compiled stylesheet.
theExecutionContext.setStylesheetRoot(theStylesheetRoot)

// Set up an XSLTInputSource object (theInputSource)
// and an XSLTResultTarget object (theResultTarget).
...
// Do the transformation. This version of the process() method uses
// the StylesheetRoot object associated with the execution context.
theProcessor.process(
         theInputSource,
         theResultTarget,
         theExecutionContext);

// Reset the processor and the execution context
// so we can perform the next transformation.
// Reset the parser liaison to clear out the
// source document we just transformed.

theProcessor.reset();
theExecutionContext.reset();
theParserLiaison.reset();
theExecutionContext.setStylesheetRoot(theStylesheetRoot);

// Perform the next transformation.
....</source>
<p>For an example, see the <link idref="samples" anchor="compilestylesheet">CompileStylesheet</link> sample.</p>
</s2><anchor name="xpath"/>
<s2 title="Working with XPath expressions">
<p>XSL stylesheets use XPath expressions to select nodes, specify conditions, and generate text for the result tree. XPath provides an API that you can call directly. For example, you may want to select nodes programmatically and do your own processing without a stylesheet.</p>
<p>For an example that executes XPath expressions against XML source files, see <link idref="samples" anchor="xpathwrapper">XPathWrapper</link>.</p>
</s2><anchor name="tracelistener"/>
<s2 title="Using TraceListener">
<p>TraceListener is a debugging abstract base class implemented by TraceListenerDefault. You can use TraceListener to trace any combination of the following:</p>
<ul>
  <li>Calls to templates</li>
  <li>Calls to template children</li>
  <li>Selection events</li>    
  <li>Result tree generation events</li>
 </ul>
<p>To construct a TraceListener with TraceListenerDefault, you need a PrintWriter and a boolean for each of these four tracing options. You can then use the XSLTEngimeImpl setTraceSelects and addTraceListener methods to add the TraceListener to an XSLTProcessor. See the <link idref="samples" anchor="tracelisten">TraceListen</link> sample application.</p>
<p>The <link idref="commandline">command-line utility (TextXSLT)</link> and TraceListen both use TraceListenerDefault to write events to the screen.</p>
</s2><anchor name="icu"/>
<s2 title="Using the ICU">
    <p>You can use the <resource-ref idref="icu"/> to extend support for encoding, number
    formatting, and sorting.</p>
    <ul>
      <li><em>Encoding</em>
      <br/> &xml4c; and &xslt4c; use UTF-16 encoding to work with Unicode data.
      If you integrate the ICU with &xml4c;, both &xml4c; and &xslt4c; use ICU support for 
      UTF-16 encoding.<br/><br/></li>
      <li><em>xsl:number element</em>
      <br/>Both &xslt4c; and the ICU provide a complete implementation for
      xsl:number.<br/><br/></li>
      <li><em>format-number()</em>
      <br/>This XSLT function includes two or three arguments (the third is
      optional): number, format pattern, and decimal-format name. &xslt4c; ignores the format
      pattern and optional decimal-format name. If you install ICU support for format-number(), 
      this function is fully supported with all its arguments.<br/><br/></li>
      <li><em>xsl:sort</em>
      <br/>If you install ICU support for xml:sort, &xslt4c; applies the Unicode sorting
      algorithm.</li>
     </ul>

    <p>To get the ICU:</p> 
    <ol>
      <li>Download and unzip the <resource-ref idref="icu-download"/> from the IBM
      developerWorks open source zone.<br/><br/></li>
      <li>Do an ICU build -- see the Windows NT or Unix build instructions in the readme.html that
       accompanies the download. 
      <br/><em>Important</em> For Windows, be sure to install the ICU on the same drive and at 
      the same level as &xslt4c; and &xml4c;.<br/><br/></li>
      <li>Set the ICU_DATA environment variable as indicated in the readme.html.</li>
    </ol>
    <s3 title="Enabling ICU support for encoding">
    <p>If you want to enable ICU support for encoding, you must integrate ICU with
    your &xml4c; build. &xml4c; uses ICU for input encoding. See
    <resource-ref idref="xerces-build-icu"/>.</p>
    <p>Once you have integrated the ICU with &xml4c;, &xslt4c; automatically uses ICU support 
    for output encoding (the xsl:output encoding attribute).</p>
     </s3>
    <s3 title="Enabling ICU support for number formatting and sorting"> 
    <p>If you only want to use the ICU to support number formatting and sorting, you do not need to
    integrate the ICU with &xslt4c;, but you must do the following in the application where you
    want to enable ICU support:</p>
    <ol>
      <li>Include the ICUBridge headers.<br/><br/></li>
      <li>Substitute ICU support for format-number(), xsl:number, and/or xsl:sort.<br/><br/></li>
      <li>Windows: Provide your application access to the ICUBridge library.<br/>
      Linux, AIX, or HP-UX 11: Rebuild the Xalan library to include the ICUBridge.</li>
      </ol>
      <p><em>ICUBridge</em></p>
     <p>All &xslt4c; references to ICU are centralized in the ICUBridge module, which supplies the
     infrastructure for enabling ICU support for number formatting and sorting.</p>
     <source>#include &lt;ICUBridge/ICUBridge.hpp&gt;
#include &lt;ICUBridge/FunctionICUFormatNumber.hpp&gt;
#include &lt;ICUBridge/ICUXalanNumberFormatFactory.hpp&gt;
#include &lt;ICUBridge/ICUBridgeCollationCompareFunctor.hpp&gt;</source>
    <p>For Windows be sure &icubridge-win;,the ICUBridge library, is on the path.</p>
    <p>For Linux, rebuild &xslt4c-linuxlib; with XALAN_USE_ICU defined, and place it on the shared library path
    (LD_LIBRARY_PATH for Red Hat Linux 6.1) or copy it to /usr/lib.</p> 
    <p>For AIX, rebuild &xslt4c-aixlib; with XALAN_USE_ICU defined, and place it on the load library
    path (LIBPATH) or copy it to /usr/lib.</p>
    <p>For HP-UX 11, rebuild &xslt4c-hplib; with XALAN_USE_ICU defined, and place it on the shared library
    path (SHLIB_PATH) or copy it to /usr/lib.</p>
    <p>For Solaris, rebuild &xslt4c-solarislib; with XALAN_USE_ICU defined, and place it on the shared library
    path (LD_LIBRARY_PATH) or copy it to /usr/lib.</p>
    
    <p><em>Number formatting</em></p>
    <p>To enable ICU support for the xsl:number element and the XSLT format-number() function, do
     the following:</p>
<source>// Install ICU support for the format-number() function.
FunctionICUFormatNumber::FunctionICUFormatNumberInstaller theInstaller;

// Create and install a factory for using the ICU for xsl:number.
ICUXalanNumberFormatFactory		theXalanNumberFormatFactory;
StylesheetExecutionContextDefault::installXalanNumberFormatFactory
                                   (&amp;theXalanNumberFormatFactory);</source>
  <p><em>Sorting</em></p> 
  <p>To enable ICU support for xsl:sort, do the following:</p>
  <source>// Set up a StylesheetExecutionContextDefault	object
// (named theExecutionContext in the following fragment),
// and install the ICUCollationCompareFunctor.
ICUBridgeCollationCompareFunctor	theICUFunctor;
theExecutionContext.installCollationCompareFunctor(&amp;theICUFunctor);</source>
  </s3>
 </s2>
</s1>