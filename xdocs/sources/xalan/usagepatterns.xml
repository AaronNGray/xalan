<?xml version="1.0" standalone="no"?> 
<!DOCTYPE s1 SYSTEM "sbk:/style/dtd/document.dtd">
<!--
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Xalan" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, Lotus
 * Development Corporation., http://www.lotus.com.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 -->
<s1 title="&xslt4c; Basic usage patterns">
<ul>
<li><link anchor="intro">Introduction</link></li>
<li><link anchor="basic">Basic procedure for performing XSL transformations</link></li>
<li><link anchor="dom">Working with DOM input and output</link></li>
<li><link anchor="params">Setting stylesheet parameters</link></li>
<li><link anchor="compiled">Compiling stylesheets</link></li>
<li><link anchor="xpath">Working with XPath expressions</link></li>
<li><link anchor="extensions">Creating and using extension functions</link></li>
<li><link anchor="tracelistener">Using the TraceListener</link></li>

</ul><anchor name="intro"/>

  <s2 title="Introduction">  
<p>&xslt4c; takes as primary input an XML source document and an XSL stylesheet, both represented by instances of <jump href="apidocs/class_XSLTInputSource.html">XSLTInputSource</jump>. These input objects may each take the form of a file or URL, a stream, or a DOM tree. The stylesheet may also take the form of a compiled stylesheet (an instance of <jump href="apidocs/class_stylesheetroot.html">StylesheetRoot</jump>.</p>
<note>If the XML source document contains a stylesheet Processing Instruction (PI), &xslt4c; uses the stylesheet this PI points to and a separate stylesheet object is not required. </note>
<p>&xslt4c; uses &xml4c; to parse text input, performs the transformation, and sends the output to an instance of <jump href="apidocs/class_xsltresulttarget.html">XSLTResultTarget</jump>, which may be configured to write to a file, a stream, or a DOM tree.</p>
<p>For detailed API documentation, see <jump href="apidocs/index.html">&xslt4c; API</jump>. For an overview of the
command-line utility, see <link idref="commandline">Command-Line Utility</link>.</p>
</s2><anchor name="basic"/>
<s2 title="Basic procedure for performing an XSL transformation">
<p>When you are setting up your application to use XSL stylesheets to transform XML documents, you must do the following:</p>
<s3 title="1. Include the required header files">
<p>Along with any required &xslt4c; and other header files, include utils/PlatformUtils.hpp from the &xml4c; distribution.</p>
</s3>
<s3 title="2. Initialize Xalan and Xerces">
<p>Use the static initializers to initialize the &xslt4c; and &xml4c; platforms. You only need to do this once per session.</p>
<source>XMLPlatformUtils::Initialize();
XSLTEngineImpl::Initialize();</source>
</s3><anchor name="step3"/>
<s3 title="3. Set up an XSLT processor with its support objects">
<p>The XSLT processor interacts with several support objects that you must set up before you can perform transformations.</p>
<source>// Create the support objects.
DOMSupportDefault          theDOMSupport;
XercesParserLiaison        theParserLiaison(theDOMSupport);
XPathSupportDefault        theXPathSupport(theDOMSupport);
XSLTProcessorEnvSupportDefault  theXSLTProcessorEnvSupport;
XObjectFactoryDefault      theXObjectFactory;
XPathFactoryDefault        theXPathFactory;

// Create the processor.
XSLTEngineImpl  theProcessor(
          theParserLiaison,
          theXPathSupport,
          theXSLTProcessorEnvSupport,
          theXObjectFactory,
          theXPathFactory);

// Connect the processor to the environment support object.
theXSLTProcessorEnvSupport.setProcessor(&amp;theProcessor);</source>
</s3>
<s3 title="4. Create context objects for the stylesheet">
<p>Use the processor and support objects to set up stylesheet construction context and execution context objects.</p>
<source>
StylesheetConstructionContextDefault  theConstructionContext(
            theProcessor,
            theXSLTProcessorEnvSupport,
            theXPathFactory);
StylesheetExecutionContextDefault      theExecutionContext(
            theProcessor,
            theXSLTProcessorEnvSupport,
            theXPathSupport,
            theXObjectFactory);</source>
</s3>
<s3 title="5. Set up input and output objects for a transformation">
<p>You must set up XSLTInputSource objects for the XML document and XSL stylesheet, and an XSLTResultTarget object to contain the transformation output.</p>
<p>Each of these objects may take the form of a file or URL, a stream, or a DOM tree. In the following fragment, the input and output are files:</p>
<source>// Use XalanDOMString to create a Unicode file name.
// The files are in the same directory as the application executable.
const XalanDOMString    theXMLFileName("foo.xml");
const XalanDOMString    theXSLFileName("foo.xsl");

// Create XSLTInputSource objects.
XSLTInputSource    theInputSource(c_wstr(theXMLFileName));
XSLTInputSource    theStylesheetSource(c_wstr(theXSLFileName));

// For the output, create an XSLTResultTarget object.
TextFileOutputStream  theOutputStream("foo.out");
XercesDOMPrintWriter  theResultWriter(theOutputStream);
XSLTResultTarget    theResultTarget(&amp;theResultWriter);
</source>
<p>For the other constructors you can use to set up input and output objects (with input and output streams, for example), see <jump href="apidocs/class_xsltinputsource.html">XSLTInputSource</jump> and <jump href="apidocs/class_xsltresulttarget.html">XSLTResultTarget</jump>. See also <link anchor="dom">Working with
DOM input and output</link>.</p>
</s3><anchor name="process"/>
<s3 title="6. Perform the transformation">
<p>Use the XSLTEngineImpl process() method to perform the transformation.</p>
<source>
theProcessor.process(
               theInputSource,
               theStylesheetSource,
               theResultTarget,
               theConstructionContext,
               theExecutionContext);</source>
<p>The XSLTResultTarget object receives the transformation output.</p>
<p>XSLTEngineImpl stores running state information, so it is not thread-safe. To perform multiple transformations, create a new instance for each transformation, or call the XSLTProcessor reset() method between each transformation.</p> 
<p>If you are using the same stylesheet to perform multiple transformations, for efficiency you should compile the stylesheet and use the appropriate XSLTEngineImpl process() method. Compiled stylesheet (StylesheetRoot) objects are also thread-safe. A single StylesheetRoot object may be called concurrently from multiple threads. For more information, see <link anchor="compiled">Compiling stylesheets</link>.</p>
<p>For a sample application that performs a transformation, see <link idref="samples" anchor="simpletransform">SimpleTransform</link>.</p> 
</s3>
</s2><anchor name="dom"/>
<s2 title="Working with DOM input and output">
<p>You can set up an XSLTResultTarget to produce a DOM when you perform a transformation. You can also use a DOM as input for a transformation, either the DOM output of another transformation, or a DOM produced by the Xerces DOMParser.</p>
<p>The following code fragments illustrate the procedures for working with DOM input and output:</p>
<source>

// Use the Xerces DOM parser to create a DOM_Document.
#include &lt;parsers/DOMParser.hpp&gt;
#include &lt;dom/DOM_Node.hpp&gt;

DOMParser  theParser;
theParser.parse("foo.xml");
const DOM_Document theDOM = theParser.getDocument();

// Set up a XercesParserLiaison and use it to wrap the DOM_Document
// in a XalanDocument.
DOMSupportDefault   theDOMSupport;
XercesParserLiaison	theParserLiaison(theDOMSupport);
XalanDocument* theDoc = theParserLiaison.createDocument(theDOM);

// Use the XalanDocument to create an XSLTInputSource object, which
// you can then use in a transformation.
XSLTInputSource		theInputSource(theDoc);
...
// If you want to produce DOM output, create an empty XalanDocument
// to contain the transformation output.
XalanDocument* docOut = theParserLiaison.createDocument();
XSLTResultTarget theDOMResultTarget(docOut);
...
// After you perform the transformation, the XalanDocument contains
// the output.
// You can also convert the XalanDocument to a Xerces DOM_Document.
DOM_Document domOut = theParserLiaison.mapXercesDocument(docOut)</source>
</s2><anchor name="params"/>
<s2 title="Setting stylesheet parameters">
<p>An XSL stylesheet can include parameters that are set at run time before a transformation takes place. When we generate the HTML documents that make up the Xalan doc set, for example, we send the stylesheet an id parameter along with each XML source document. The id identifies that document and enables the stylesheet to integrate it into the overall doc set.</p>
<p>To set a stylesheet parameter, use one of the <jump href="apidocs/class_xsltengineimpl.html">XSLTEngineImpl</jump> setStylesheetParam() methods. Both methods take two arguments: the parameter name (a XalanDOMstring) and the expression (a XalanDOMString or an XObject). The XObject option is useful when you are working with the XPath API. For example, you could use the XObject returned by an Xpath function to set a stylesheet parameter.</p>
<note>If the expression is a string and you are using XalanDOMString for the input parameter, enclose it in single quotes to make it a string expression.</note>
<p>You can include the -param flag with two arguments when you call the <link idref="commandline">command line utility</link>. The first argument is the parameter name or key, and the second argument is the string expression (in single quotes). For example:</p>
<p><code>TestXSLT -in foo.xml -xsl foo.xsl -param param1 'boo'</code></p>
<p>If the string expression includes spaces, first enclose the string in single quotes so it is interpreted as a string expression, and then enclose the resulting string in double quotes so it is interpreted as a single argument. For example:</p>
<p><code>TestXSLT -in foo.xml -xsl foo.xsl -param param1 "'hello there'"</code></p>
<p>The <link idref="samples" anchor="usestylesheetparam">UseStylesheetParam</link> sample application also uses a command-line parameter.</p>
</s2><anchor name="compiled"/>
<s2 title="Compiling stylesheets">
<p>When &xslt4c; performs a transformation with the <link anchor="process">XSLTEngineImpl process() method used above</link>, it starts by compiling the stylesheet into a binary representation. If you intend to use the same stylesheet to perform multiple transformations, you can enhance efficiency by explicitly compiling the stylesheet and using another XSLTEngimeImpl process() method for each transformation. A compiled stylesheet (a <jump href="apidocs/class_stylesheetroot.html">StylesheetRoot</jump> object) thread safe, so it even supports concurrent access by multiple clients. If, for example, you are setting up a server application to perform transformations, you can improve performance by compiling any stylesheets the application repeatedly uses.</p>
<p>A compiled stylesheet requires its own XPath and XObject factory support objects, independent of the support objects for an XSLT processor. So after you have set up the XSLT processor with its support objects, set up other
factory support objects and use them to create a construction context for the stylesheet:</p>
<source>// Set up the XSLT processor with its support objects
DOMSupportDefault          theDOMSupport;
XercesParserLiaison        theParserLiaison(theDOMSupport);
XPathSupportDefault        theXPathSupport(theDOMSupport);
XSLTProcessorEnvSupportDefault  theXSLTProcessorEnvSupport;
XObjectFactoryDefault      theXObjectFactory;
XPathFactoryDefault        theXPathFactory;

// Create the processor and connect to the
// environment support object.
XSLTEngineImpl  theProcessor(
          theParserLiaison,
          theXPathSupport,
          theXSLTProcessorEnvSupport,
          theXObjectFactory,
          theXPathFactory);
theXSLTProcessorEnvSupport.setProcessor(&amp;theProcessor);
...
// Create an XPath factory support object for the stylesheet,
// so it will have its own factory-created XPath instances
// (separate from the XSLT processor XPath objects).
XPathFactoryDefault        theStylesheetXPathFactory;

// Use this XPath factory support object to create a stylesheet 
// construction context.
StylesheetConstructionContextDefault  theConstructionContext(
            theProcessor,
            theXSLTProcessorEnvSupport,
            theStylesheetXPathFactory);

 // The execution context uses the same factory support objects as
 // the processor.
 StylesheetExecutionContextDefault    theExecutionContext(
            theProcessor,
            theXSLTProcessorEnvSupport,
            theXPathSupport,
            theXObjectFactory);</source>
<p>Compile the stylesheet, add the StylesheetRoot object to the execution context, and start performing transformations. Use the XSLTEngineImpl process() method (see below) that takes advantage of the compiled stylesheet. Be sure to reset the processer and execution context between each transformation. For example:</p>
<source>
// Compile the stylesheet.
StylesheetRoot* const	theStylesheetRoot =
          theProcessor.processStylesheet(
                theStylesheetSource,
                theConstructionContext);

// Set the execution context object to use the compiled stylesheet.
theExecutionContext.setStylesheetRoot(theStylesheetRoot)

// Set up an XSLTInputSource object (theInputSource)
// and an XSLTResultTarget object (theResultTarget).
...
// Do the transformation. This version of the process() method uses
// the StylesheetRoot object associated with the execution context.
theProcessor.process(
         theInputSource,
         theResultTarget,
         theExecutionContext);

// Reset the processor and the execution context
// so we can perform the next transformation.
// Reset the parser liaison to clear out the
// source document we just transformed.

theProcessor.reset();
theExecutionContext.reset();
theParserLiaison.reset();
theExecutionContext.setStylesheetRoot(theStylesheetRoot);

// Perform the next transformation.
....</source>
<p>For an example, see the <link idref="samples" anchor="compilestylesheet">CompileStylesheet</link> sample.</p>
</s2><anchor name="xpath"/>
<s2 title="Working with XPath expressions">
<p>XSL stylesheets use XPath expressions to select nodes, specify conditions, and generate text for the result tree. XPath provides an API that you can call directly. For example, you may want to select nodes programmatically and do your own processing without a stylesheet.</p>
<p>For an example that executes XPath expressions against XML source files, see <link idref="samples" anchor="xpath">XPathWrapper</link>.</p>
</s2><anchor name="tracelistener"/>
<s2 title="Using TraceListener">
<p>TraceListener is a debugging abstract base class implemented by TraceListenerDefault. You can use TraceListener to trace any combination of the folllowing:</p>
<ul>
  <li>Calls to templates</li>
  <li>Calls to template children</li>
  <li>Selection events</li>    
  <li>Result tree generation events</li>
 </ul>
<p>To construct a TraceListener with TraceListenerDefault, you need a PrintWriter and a boolean for each of these four tracing options. You can then use the XSLTEngimeImpl setTraceSelects and addTraceListener methods to add the TraceListener to an XSLTProcessor. See the <link idref="samples" anchor="tracelisten">TraceListen</link> sample application.</p>
<p>The <link idref="commandline">command-line utility (TextXSLT)</link> and TraceListen both use TraceListenerDefault to write events to the screen.</p>
</s2>
</s1>